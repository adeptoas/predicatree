# PredicaTree

This is a (somewhat) lightweight library to parse and execute predicate-based structure algorithms.

A useful application example is dynamic sorting.

## Installation

Add this to `composer.json`:

```json
"require": {
	"adeptoas/predicatree": "^1.0.0"
}
```

Make sure to merge your `require`-blocks!

## Usage

Currently only supports sorting.

### Programs

`Programs` are sequences of predicates executed in order to give some kind of result.
You can create your own by extending from `Adepto\PredicaTree\Program\Program`.
Be sure to call the constructor:
```php
protected function __construct($subject, array $predicates, array $aprioriData = [])
```
It is marked as `protected` to encourage use of static factory methods.
Some pre-defined programs are explained below.

Every program is run by calling `$program->run()`. Be aware that this only _executes_ the program.
If you actually want to retrieve the computation result, you have to call `$program->getResult()`,
which will run the program automatically (if not already done).

Every program has a `subject` which is the data the program operates on.
A program can have optional `apriori` data, which is an array specifying any value you want

#### SortProgram

Sorting programs are generated by `SortProgram::build(array $data)`.

The data array is specified as follows:
```php
[
    'apriori'       =>  array,
    'collection'    =>  [
        'a collection specifier (see section below)'
    ],
    'predicates'    =>  [
        'a sequential list',
        'of if-then predicates',
        'just as specified below'
    ]
]
```

##### Collections

In order to sort stuff, you have to give it order. Therefor, this library contains some collection types.
Features basic sort operations like `add`, `remove` and `move`.

Collections are specified by their type (currently `Dictionary` and `OrderedSet`) and their items like so:
```php
[
    'type'  =>  'OrderedSet',
    'items' =>  [1, 3, 7, 9, 11]
]
```

### Predicates

Predicates represent the `if-then` rules in this package, and are specified as follows:
```php
[
    'if'    =>  [
        'condition' =>  'CONDITION-NAME',
        'arguments' =>  ['all', 'arguments', 'for', 'the', 'condition']
    ],
    'then'  =>  [
        'action'    =>  'ACTION-NAME',
        'arguments' =>  ['all', 'arguments', 'for', 'the', 'action']
    ]
]
```

Please note that arguments are passed as sequential arrays and thus are **order-sensitive**

Pre-defined conditions
- `EQUAL`: two (obvious) arguments, plus an optional boolean for strict comparison
- `BETWEEN`: needle followed by two boundaries
- `IN`: needle and haystack, plus an optional boolean for strict comparison
- `STR-BEGINS`: needle and haystack
- `STR-CONTAINS`: needle and haystack
- `STR-ENDS`: needle and haystack
- `NOT`: a fully specified predicate (as array). Attention: Sequential array with one argument formatted as array means double array braces!!
- `AND`: any amount of conditions specified as array
- `OR`: any amount of conditions specified as array

Currently features methods:
- `COLLECTION`: first argument is collection method, followed by whatever more arguments necessary
- `EVAL`: a fully specified predicate (as array)
- `PRINT`: a string and an optional second boolean for applying JSON encoding
- `CHAIN`: any amount of actions specified as array

Apriori contents can be accessed by prefixing an argument with `::`.
Nested array access can be realised by infixing the same `::` in between keys.

Subject contents can be accessed _during program execution_ by prefixing an argument with `__`.
The part after this marker specifies the _exact_ key under which the collection will be accessed.
Plain `__` accesses the entire collection contents as array

## Examples

Examples will be added to the `Examples/` directory once I come up with meaningful examples that don't involve confidential data from my dayjob.